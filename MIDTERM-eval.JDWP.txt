* The midterm evaluation progress report
  
	Byeongcheol Lee
	bclee@cs.utexas.edu
	July 11 2008

* Progress
  + 1.5 months (05/26/08 ~ 07/11/08)
  + Implemented features
    + Breakpoint
    + Call stack dump
    + Expression evaluation without a method call
    + Class/thread inspection
    + Fact.exp and Fact.java demonstrate the implementation.
    + Read README.JDWP.txt for more information.
  + achievement compared with the proposal [SOC_PROPOSAL.JDWP.txt]
    + Everything is fine except for the single stepping.

* TODO work
  + 1.5 months (07/14/08 ~ 09/01/08)
    + Method call in the expression evaluation
    + Single stepping
    + More testing scripts with SPECJVM98 and DaCapo
    + Write 2-3 pages tutorial to show how to interact with JDB and eclipse JDT
    + Submit the sample code to Google (09/03/08)

* Technical issues

  + Break point implementation in baseline compiler

    + NOP and TRAP: During the code generation, the baseline compiler
    inserts a NOP machine instruction for each byte code. When the
    JDWP agent sets a break point within a method, the agent locates
    the corresponding NOP machine, and overwrite a trap instruction
    (INT xx). The JikesRVM hits the trap break point at some point,
    and moves its execution control to the JDWP agent code, which
    suspends the current thread. When the agent resumes the execution,
    the agent simply sets the program counter right after the trap
    instruction.  

    + PROS: Perhaps, this would be simplest and robust implementation
    without relying on any special hardware and OS support. 

    + CONS: This would increase the baseline machine code size by
    probably 10-20% since this implementation adds 1-2 bytes for each
    byte code.

    + DECISION: The hardest issue was resuming the execution and
    keeping the break point at the same time. In theory, we can
    implement without the padded NOP, but this may increase the
    implementation complexity, decrease the robustness and lose
    portability. I'd like to delay the advance implementation until we
    got all the basic JDWP functionalities and user experience since
    this advanced implementation may end up with overkilling.

  + Method entry/exit event in JDWP

    In compile-only approach as in JikesRVM, this event would be
    challenging to implement in an efficient way. This means that we
    might have to set break points for all the compiled methods'
    entries and exits. The following is the specification:

    "Case MethodEntry - if eventKind is JDWP.EventKind.METHOD_ENTRY:
    Notification of a method invocation in the target VM. This event
    is generated before any code in the invoked method has
    executed. Method entry events are generated for both native and
    non-native methods. In some VMs method entry events can occur for
    a particular thread before its thread start event occurs if
    methods are called as part of the thread's initialization.

    Case MethodExit - if eventKind is JDWP.EventKind.METHOD_EXIT:
    Notification of a method return in the target VM. This event is
    generated after all code in the method has executed, but the
    location of this event is the last executed location in the
    method. Method exit events are generated for both native and
    non-native methods. Method exit events are not generated if the
    method terminates with a thrown exception."

   [http://java.sun.com/javase/6/docs/platform/jpda/jdwp/jdwp-protocol.html#JDWP_Event_Composite]

   This actually is very powerful feature than the normal debuggers
   such as GDB. Since the debugger can stop the debugee program at
   each method entry and exit, this even enables the call graph or
   calling context tree profiling:

   (bash)jdb -launch Fact
   Initializing jdb ...
   main[1] trace go methods 
   main[1] cont
   Method entered: "thread=main", Fact.main(), line=9 bci=0
   Method entered: "thread=main", Fact.fact(), line=18 bci=0
   Method entered: "thread=main", Fact.fact(), line=18 bci=0
   Method entered: "thread=main", Fact.fact(), line=18 bci=0
   Method entered: "thread=main", Fact.fact(), line=18 bci=0
   Method entered: "thread=main", Fact.fact(), line=18 bci=0
   Method exited: return value = 1, "thread=main", Fact.fact(), line=19 bci=5
   Method exited: return value = 1, "thread=main", Fact.fact(), line=21 bci=14
   Method exited: return value = 2, "thread=main", Fact.fact(), line=21 bci=14
   Method exited: return value = 6, "thread=main", Fact.fact(), line=21 bci=14
   Method exited: return value = 24, "thread=main", Fact.fact(), line=21 bci=14
   Method exited: return value = <void value>, "thread=main", Fact.main(), line=10 bci=28

   The question is "do we really want to have this feature?" I'm not
   sure if the eclipse JDT actually uses this feature. Personally I
   had never used this feature before I read the JDWP document.

  + Power PC port

   How much do we want support power PC? The only problematic part is
   the break point now. We have one old power PC machine, and I can in
   theory do this job. However, I did not have much experience with
   the JikesRVM on the Power PC, and our machine had troubles
   before. The work time and effort with the Power PC is quite
   unpredictable. I have two choices.

    1. Devote some of my time on the power PC work. --> this may risk
       the whole project schedule.

    2. Do not implement this summer, but keep explicit portability
       interface.

  What would be the wise choice?

