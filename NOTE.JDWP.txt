* Controlling the execution: breakpoint and single stepping
 
  patch + trap ==> baseline code generator checks

  + The proposed approach for the breakpoint and single stepping was
  using code patching and trapping. For instance, save a machine
  instruction in the JIT compiled machine code at a breakpoint and
  insert a breakpoint instruction (int xx). If the program reaches
  this trap instruction, the control moves from the user code to the
  OS and from the OS code to the JikesRVM breakpoint handler. After
  returning from the break point handler, the JikesRVM executes the
  original machine instruction at the break point by either
  interpreting the machine code or back-patching the original machine
  code and performing hardware supported machine code single
  stepping. This is how the basic breakpoint works in GDB-like
  out-of-process debugger, and single stepping works by determining
  the next dynamic byte code and setting a breakpoint. The motivation
  for this proposal was to minimize the change in the existing
  JikesRVM.

  + The other alternative is letting the code generator to take care
  of this job. For each user program point (the method and byte code
  index), the JikesRVM allocates a flag variable array. The JIT
  compiled code checks the breakpoint flag variable for each byte
  code. If the flag value is true, the execution moves to the break
  point handler. For the single stepping, each thread has a flag
  variable (singleStep). The JIT compiled code check this flag
  variable, and moves to the single step handler if this flag is
  set. The advantage is portability since this does not require any OS
  and architectural support. The drawback would be using more memory,
  and changes in the JIT-code.

  + I ended up with the portable code generator solution. The real
  motivation for this departure from the proposed code patching
  solution is the single stepping. As a primitive, we need byte code
  level stepping. Proposed solution was to set a breakpoint at the
  next dynamic byte code instruction. However, I found that
  determining the next dynamic byte code instruction is not feasible
  in the JikesRVM. For instance, consider the following JVM byte code
  instruction:

         getfield  #...

  The next byte code instruction is quite unpredictable in
  general. The result may depend on the class loading if the class in
  the field reference is resolved. The next byte instruction could be
  the first byte code in the class initializer of the target
  class. This could be the first class initializer code of the one
  super class of the target class.  The next byte code could the
  exception handler code if the object argument is null or the class
  loading causes an exception. This is due to the dynamic loading at
  the byte code level, and this differentiates the byte code single
  stepping from the general machine code level stepping.

  + Even if I can determine all the possible next dynamic byte code
  instructions, the implementations is too complex. I need to keep
  updating the breakpoints for all the stepping. This seems to make
  source files too hard to maintain.

  + I found that the source codes are greatly simplifed afer moving to
  the portabl code generator solution. For instance, the JikesRVM has
  to receive the method compilation event to update the breakpoint if
  the breakpoint request happened before the method compilation. If
  the method is recompiled and inlined (for instance), the JikesRVM
  has to take care of this with the given list of
  breakpoints. However, JikesRVM does not need to keep track of all
  these cases since the JIT compiled code is always up-to-date with
  the mutable set of the breakpoints. Also, this simplies JIT code
  coherence issue in the power pc.

* Power PC support

  + The current source code does not support power pc, but this won't
  be a hard work as we have power pc expert. This will be about adding
  around 100 source lines to the power pc specific baseline compiler
  sourc files.

* Single stepping

  * General issue: Unlike other JDWP debugging events, the single step
    requires the JDWP agent to keep the program context when the agent
    gets the request. In other words the single step completion point
    is dependent on the request point. For a machine level, the step
    completion point is next dynamic byte code instrution. For a
    source level, the completion point is the first dynamic
    instruction with different source line with respect the source
    line at the single step request.

    JVMTI/JDWP: JVMTI provides a single stepping at the byte code
    level, and JDWP agent exposes the single stepping at both byte and
    source code levels. A sequence of JVMTI single step events may
    constitute a single JDWP single stepping if the JDWP sinigle step
    request was at the source line level. If JDWP client asks more
    filters such as class exclusion, the JDWP agent would skip more
    JVMTI single stepping events.

    JDWP agent should keep the suspened location when the JDWP client
    requests the single step event. Then the JDWP agent enables the
    JVMTI byte code level single step, and resumes the application
    thread. The application thread executes one byte code instruction,
    and notifies this byte code completion event. The JDWP agent
    compares the previouly recorded location and the new location. If
    the difference between these two locations is far enough in terms
    of step depth and step size, the JDWP agent notifies the JDWP
    client of this JDWP level stepping event. Otherwise the JDWP agent
    resumes the execution, and repeat this process until it observes
    enough execution progress in the application.

    + JDWP Single Step

    "Case Step - if modKind is 10: Restricts reported step events to
    those which satisfy depth and size constraints. This modifier can
    be used with step event kinds only.
       threadID  thread   Thread in which to step 
       int         size   size of each step. See JDWP.StepSize 
       int        depth   relative call stack limit. See JDWP.StepDepth"
    [http://java.sun.com/javase/6/docs/platform/jpda/jdwp/jdwp-protocol.html#JDWP_EventRequest_Set]

    "Case SingleStep - if eventKind is JDWP.EventKind.SINGLE_STEP:
       Notification of step completion in the target VM. The step
       event is generated before the code at its location is executed.
       int        requestID	Request that generated event 
       threadID	     thread	Stepped thread 
       location	   location	Location stepped to"
     [http://java.sun.com/javase/6/docs/platform/jpda/jdwp/jdwp-protocol.html#JDWP_Event_Composite]

    + JVMTI Single Step request and callback

    "jvmtiError SetEventNotificationMode(jvmtiEnv* env, jvmtiEventMode
      mode, jvmtiEvent event_type, jthread event_thread, ...)"
    [http://java.sun.com/j2se/1.5.0/docs/guide/jvmti/jvmti.html#SetEventNotificationMode]

    "void JNICALL SingleStep(jvmtiEnv *jvmti_env, JNIEnv* jni_env,
      jthread thread, jmethodID method, jlocation location)
    
    Typically, single step events represent the completion of one VM
    instruction as defined the Java Virtual Machine
    Specification. However, some implementations may define locations
    differently."
    [http://java.sun.com/j2se/1.5.0/docs/guide/jvmti/jvmti.html#SingleStep]

    "StepDepth Constants
      INTO	0	Step into any method calls that occur before the end of the step.  
      OVER	1	Step over any method calls that occur before the end of the step.  
      OUT	2	Step out of the current method."
    [http://java.sun.com/javase/6/docs/platform/jpda/jdwp/jdwp-protocol.html#JDWP_StepDepth]

    "StepSize Constants
      MIN     0	        Step by the minimum possible amount (often a bytecode instruction).  
      LINE    1         Step to the next source line unless there is no line number
			information in which case a MIN step is done instead."
      [http://java.sun.com/javase/6/docs/platform/jpda/jdwp/jdwp-protocol.html#JDWP_StepSize]

* Method Invocation at a break point
  
  This is to support expression evalation that contains a method
  call. For instance, consider "eval Fact.fact(2) + 1"

  ------------------------------------------------------------------
  (bash) cat -n Fact.java
    ...
     5	public class Fact {
    ...
     8	  public static void main(String[] args) {
     9	    System.out.println("fact(4) = " + fact(4));
    10	  }
    ...
    17	  private static int fact(int n) {
    18	    if ( n <= 0 ) {
    19	      return 1;
    20	    } else {
    21	      return n * fact( n - 1 );
    22	    }
    23	  }
    24	}

  (bash) jdb -connect 'com.sun.jdi.RawCommandLineLaunch:command=rvm
  "-Xrunjdwp:transport=dt_socket,address=8000,suspend=y"
  Fact',address=8000 -launch

  MainThread[1] stop in Fact.main
  Set breakpoint Fact.main
  MainThread[1] cont
  Breakpoint hit: "thread=MainThread", Fact.main(), line=9 bci=0
  9        System.out.println("fact(4) = " + fact(4));

  MainThread[1] eval Fact.fact(2) + 1
   Fact.fact(2) + 1 = 3
  ------------------------------------------------------------------

  Here, the JDB internally sends the JDWP agent a request to invoke
  Fact.fact method with the integer argument value 2, and the JDWP
  agent internally activates the method via reflective call. The
  following is JDWP's related protocol commands:

  ------------------------------------------------------------------
      ClassType.InvokeMethod --> "Invokes a static method."

      ClassType.newInstance --> "Creates a new object of this type,
      invoking the specified constructor."

      ObjectReference.InvokeMethod --> "Invokes a instance method."

  [http://java.sun.com/javase/6/docs/platform/jpda/jdwp/jdwp-protocol.html]
  ------------------------------------------------------------------

  Inside the JikesRVM/JDWP, All three requests end up here:

    gnu.classpath.jdwp.VMVirtualMachine.executeMethod(..)

  The background JDWP helper thread reads the method invocation
  protocol command, and resumes the suspened application thread at the
  break point. At this time, the resumed application thread is in the
  following JDWP agent method.

  gnu.classpath.jdwp.VMVirtualMachine.ThreadInfo.suspendCurrentThread()
  
  The awaken application thread notices a method invocation request,
  and executes the target method instead of returning to the
  application code at the breakpoint. After finishing the method
  invocation, this application thread returns to the suspened status.

  Breakpoint Hit during Method Invocation: JikesRVM/JDWP agent skips
  breakpoints and any other JDWP events during method invocation. The
  first reason is because this decision would simplify the
  implementation. The second reason is that the current GNU class path
  JDWP code (gnu.classpath.jdwp) is not suitable for the another
  alternative. Let me explain the issues in the following.

          skipping vs. nested break state?

  One issue with the method invocation is how to deal with the break
  point during the method invocation. One possibility is ignoring the
  breakpoints during the method invocation. The other possibility is
  suspending the program and allowing nested break state. Which one is
  better is not clear. Rosenberg's book [How debuggers work]
  recommands skipping the breakpoint since the return of investment is
  not clear. Visual studio 2003 skipped the break point, but Visual
  studio 2005 allowed the nested break state
  [http://blogs.msdn.com/jmstall/archive/2005/03/23/400794.aspx]. The
  JDWP specification for the method invocation does not show any clear
  position about this. The hotspot VM appears catures the break point
  event during the method invocation, but it does not support the
  nested break state. The Apache DLRVM surprisingly appears as if it
  supports the nested break state.

  ------------------------------------------------------------------
  (bash) jdb -version
  This is jdb version 1.6 (J2SE version 1.6.0)
  (bash) jdb -launch Fact
  main[1] stop at Fact:18
  main[1] cont
  Breakpoint hit: "thread=main", Fact.fact(), line=18 bci=0
  18        if ( n <= 0 ) {
  main[1] eval Fact.fact(3)

  Breakpoint hit: "thread=main", Fact.fact(), line=18 bci=0
  18        if ( n <= 0 ) {
  main[1] eval Fact.fact(3)
   com.sun.jdi.InternalException: Unexpected JDWP Error: 502
   Fact.fact(3) = null 
  main[1] exit
  ------------------------------------------------------------------

  ------------------------------------------------------------------
  (bash) jdb -launch -connect com.sun.jdi.CommandLineLaunch:
	 vmexec=java,home=/var/local/bclee/harmony-jdk-653525
	  Fact 1
  main[1] stop at Fact:18
  main[1] cont
  Breakpoint hit: "thread=main", Fact.fact(), line=18 bci=0
  18        if ( n <= 0 ) {
  main[1] eval Fact.fact(3)

  Breakpoint hit: "thread=main", Fact.fact(), line=18 bci=0
  18        if ( n <= 0 ) {

  main[1] eval Fact.fact(3)

  Breakpoint hit: "thread=main", Fact.fact(), line=18 bci=0
  18        if ( n <= 0 ) {
  main[1] exit
  ------------------------------------------------------------------  


  ------------------------------------------------------------------------
  coral:~/w/jdwp$java 
  ...
    -agentlib:<libname>[=<options>]
              load native agent library <libname>, e.g. -agentlib:hprof
              see also, -agentlib:jdwp=help and -agentlib:hprof=help
    -agentpath:<pathname>[=<options>]
              load native agent library by full pathname
    -javaagent:<jarpath>[=<options>]
              load Java programming language agent, see java.lang.instrument
  ...
  ------------------------------------------------------------------------

* JikesRVM/JDWP options

 The JikesRVM will implement the subset of the SUN JVM's JDWP command
 line options:

 [http://java.sun.com/javase/6/docs/technotes/guides/jpda/conninv.html#Invocation]

  option name       JikesRVM implementation
  -----------------------------------------
  help              YES                            
  transport         dt_socket only        gnu.classpath.jdwp.transport._TRANSPORT_PROPERTY
  server            YES                   gnu.classpath.jdwp.transport.SocketTransport._PROPERTY_SERVER
  address           YES                   gnu.classpath.jdwp.transport.SocketTransport._PROPERTY_ADDRESS
  timeout           NO
  launch            NO
  onthrow           NO
  onuncaught        NO
  suspend           YES                   gnu.classpath.jdwp.Jdwp._PROPERTY_SUSPEND

  The following is the help message from JikesRVM/JDWP.

  ---------------------------------------------------------------------------
  coral:~/w/jdwp$rvm -Xrunjdwp:help
  -Xrunjdwp[:help]		Print usage of the JDWP agent.
  -Xrunjdwp:[<option>=<value>, ...]		Configure the JDWP agent.

  Option             Default value       Description
  suspend=y|n        y                   Suspend VM before starting application.
  transport=...      none                Name transport. e.g. dt_socket
  server=...         n                   Listens for the debugger
  address=...        none                Transport address for the connection
  verbose=..         0                   JDWP subsystem verbose level
  ---------------------------------------------------------------------------

  An issue here is the default value for the "suspend." SUN JVM has
  "y" as a default "suspend" value, but the GNU classpath JDWP has "n"
  default value. For the compatibility with the existing tools, I'd
  prefer "y" as default value. I have two choices for this. The first
  one is to ask the GNU classpath community to switch to the "y"
  default value. The second one is that the JikesRVM's porting layer
  handles this.


* JikesRVM's command line argument for the JDWP agent launch.

  JikesRVM would support the following two types of the command line
  arguments.

  1. old: "-Xdebug -Xrunjdwp:<name1>[=<value1>],<name2>[=<value2>]..."

  2. new: "-agentlib:jdwp=<name1>[=<value1>],<name2>[=<value2>]..."

   -- Sun VM Invocation Options
  [http://java.sun.com/javase/6/docs/technotes/guides/jpda/conninv.html#Invocation]

  Both formats have the same effect of initializing the JDWP agent,
  and passing the JDWP agent a set of <name,value> pairs to decide how
  to connect to the debugger and which transport channel to use. Both
  SUN hotspot and IBM J9 support all these two JDWP argument
  formats. The JDB in the JDK 1.6 internally uses the old format, and
  the Eclipse JDT 3.3.2 uses the new format.

  I'm a little bit concerned with the new JDWP argument format. The
  new JDWP command line argument seems to assume that the JDWP agent
  runs in the native mode. In addition, the JDPA documentation shows
  doubtful view about the Java agent approach:

  "It is clear from experience that debugger support code, running on
  the debuggee and written in Java, contends with the debuggee in ways
  that cause hangs and other undesired behavior. Thus, the back-end is
  native code. This, in turn, implies that the JVM TI be a pure native
  interface."

   -- Java Platform Debugger Architecture
  [http://java.sun.com/javase/6/docs/technotes/guides/jpda/architecture.html]

* Connecting JikesRVM to the existing debuggers such as JDB and Eclipse JDT

  I'd like to argue that the JikesRVM build image respects the
  JRE-like directory structure.

  ${JAVA_HOME}/bin
  ${JAVA_HOME}/bin/rvm
  ...

  This JRE-like structure is what the JDB and the eclipse JDT
  assume. This JRE-like structure would not be required to claim
  JVM-compatibility, and in theory the Java Platform Debugger
  Architecture (JPDA) does not enforce this JRE-like
  structure. However, it's better to respect the existing
  implementations to exploit the existing debuggers such as JDB and
  eclipse JDT.

  JDB: The SUN JPDA documentation shows the following 8 types of the
  connectors:

   + com.sun.jdi.CommandLineLaunch  Transport: dt_socket
   + com.sun.jdi.RawCommandLineLaunch  Transport: dt_socket
   + com.sun.jdi.SocketAttach  Transport: dt_socket
   + com.sun.jdi.SocketListen  Transport: dt_socket
   + com.sun.jdi.ProcessAttach  Transport: local
   + sun.jvm.hotspot.jdi.SACoreAttachingConnector  Transport: filesystem
   + sun.jvm.hotspot.jdi.SADebugServerAttachingConnector  Transport: RMI
   + sun.jvm.hotspot.jdi.SAPIDAttachingConnector  Transport: local process  
  [http://java.sun.com/javase/6/docs/technotes/guides/jpda/conninv.html#Connectors]

  Out of these 8 types, com.sun.jdi.CommandLineLaunch is the typical
  one. This connector takes the following three variables.

    * home: the JRE home directory. e.g. /var/local/bclee/jdk1.6/jre
    * vmexec: the JVM file name. e.g java
    * main: main class and its arguments e.g. Fact 1

  JDB internally decides the values for these variables, and creates a
  JVM process like the following.

    ${home}/bin/${vmexec} -Xdebug
    -Xrunjdwp:transport=dt_socket,address=...,suspend=y ${main}

  ---------------------------------------------------------------
  coral:~/w/jdwp$which jdb
  /var/local/bclee/jdk1.6/bin/jdb

  coral:~/w/jdwp$jdb Fact 1
  Initializing jdb ...
  > stop in Fact.main
  > run
  Breakpoint hit: "thread=main", Fact.main(), line=5 bci=0
  5        System.out.println("fact(4) = " + fact(4));
  main[1] 
  [5]+  Stopped                 

  coral:~/w/jdwp$ps -w h -C java -o args
  /var/local/bclee/jdk1.6/jre/bin/java -Xdebug
  -Xrunjdwp:transport=dt_socket,address=coral.cs.utexas.edu:38076,suspend=y
  Fact 1
  ---------------------------------------------------------------

  JDB can allow the user to specifiy some of these debugger connector
  variables:

  ---------------------------------------------------------------
  coral:~/w/jdwp$jdb -connect
  com.sun.jdi.CommandLineLaunch:vmexec=java,home=/var/local/bclee/ibm-java2-i386-50/jre
  Fact 1

  Initializing jdb ...
  > stop in Fact.main
  > run
  Breakpoint hit: "thread=main", Fact.main(), line=5 bci=0
  5        System.out.println("fact(4) = " + fact(4));
  main[1] 
  [5]+  Stopped                 

  coral:~/w/jdwp$ps -w h -C java -o args
  /var/local/bclee/ibm-java2-i386-50/jre/bin/java -Xdebug
  -Xrunjdwp:transport=dt_socket,address=coral.cs.utexas.edu:36139,suspend=y
  Fact 1
  ----------------------------------------------------------------

  Eclipse JDT: the Eclipse JDT allows various types of JVM debuggee
  environments such as Eclipse Application, Java Applet, Java
  Application, JUnit, OSGI framework and Remote Java Application. Out
  of these, the Java Application configuration would be the common
  case for the JikesRVM. This configuration seems to use the same
  launch interface as the jdb:

  ----------------------------------------------------------------
  coral:~/w/jdwp$ps -w h -C java -o args
  /v/filer4b/software/java5/jdk1.5.0/linux/bin/java -classpath
  /var/local/bclee/w/SPECjvm98
  -agentlib:jdwp=transport=dt_socket,suspend
  ----------------------------------------------------------------  

  The eclipse allows the user to specify a particular JRE for the
  debuggging, and it perhaps internally uses the
  com.sun.jdi.CommandLineLaunch or equivalent.

  The major difference between JDB and eclipse JDT is the way to
  specify the JDWP agent. The JDB in the JDK 1.6 still uses the old
  command line argument, and the eclipse JDT uses the new one. The Sun
  recommends using the new "-agentlib:jdwp" instead of the old
  "-Xrunjdwp:."
  [http://java.sun.com/javase/6/docs/technotes/guides/jpda/conninv.html#Invocation]

* Interface to the existing Java debuggers

 The JikesRVM will implement the subset of the SUN JVM's JDWP command
 line options:

 [http://java.sun.com/javase/6/docs/technotes/guides/jpda/conninv.html#Invocation]

  option name       JikesRVM implementation
  -----------------------------------------
  help              YES                            
  transport         dt_socket only        gnu.classpath.jdwp.transport._TRANSPORT_PROPERTY  server            YES                   gnu.classpath.jdwp.transport.SocketTransport._PROPERTY_SERVER
  address           YES                   gnu.classpath.jdwp.transport.SocketTransport._PROPERTY_ADDRESS
  timeout           NO
  launch            NO
  onthrow           NO
  onuncaught        NO
  suspend           YES                   gnu.classpath.jdwp.Jdwp._PROPERTY_SUSPEND

  The following is the help message from JikesRVM/JDWP.

  ---------------------------------------------------------------------------
  coral:~/w/jdwp$rvm -Xrunjdwp:help
  -Xrunjdwp[:help]		Print usage of the JDWP agent.
  -Xrunjdwp:[<option>=<value>, ...]		Configure the JDWP agent.

  Option             Default value       Description
  suspend=y|n        y                   Suspend VM before starting application.
  transport=...      none                Name transport. e.g. dt_socket
  server=...         n                   Listens for the debugger
  address=...        none                Transport address for the connection
  verbose=..         0                   JDWP subsystem verbose level
  ---------------------------------------------------------------------------

  An issue here is the default value for the "suspend." SUN JVM has
  "y" as a default "suspend" value, but the GNU classpath JDWP has "n"
  default value. For the compatibility with the existing tools, I'd
  prefer "y" as default value. I have two choices for this. The first
  one is to ask the GNU classpath community to switch to the "y"
  default value. The second one is that the JikesRVM's porting layer
  handles this.



* Jikes RVM JDWP status at the beginning

 + branch 

  (bash) svn checkout  https://jikesrvm.svn.sourceforge.net/svnroot/jikesrvm/rvmroot/branches/RVM-33-JdwpSupport jdwp
  (bash) cd jdwp

 + log	
  (bash) svn log -r 13021:14081
  r13021 --> simply branch creation
  r13022 --> jdwp.13022.patch
  r13029 --> jdwp.13029.patch
  r13210 --> jdwp.13210.patch
  r13354 --> jdwp.13354.patch
  r13361 --> jdwp.13392.patch
  r13392 --> merge with r13380 trunk?
  r13403 --> jdwp.13403.patch

  + JikesRVM codes

    + The followings are related to the Jikes RVM port of the JDWP.

    file name                                         patches
    libraryInterface/GNUClasspath/LGPL/src/gnu/classpath/jdwp/VMMethod.java                                      r13022        r13354
    libraryInterface/GNUClasspath/LGPL/src/gnu/classpath/jdwp/VMIdManager.java                                   r13022
    libraryInterface/GNUClasspath/LGPL/src/gnu/classpath/jdwp/VMFrame.java                                       r13022        r13354
    libraryInterface/GNUClasspath/LGPL/src/gnu/classpath/jdwp/VMVirtualMachine.java                              r13022        r13354 r13361 r13403
    build/primordials/Classpath-0.95.txt                                                                         r13022        r13354
    rvm/src/org/jikesrvm/VM_CommandLineArgs.java                                                                 r13022        r13354
    rvm/src/org/jikesrvm/VM.java                                                                                        r13210 r13354
    rvm/src/org/jikesrvm/VM_Callbacks.java                                                                              r13210 r13354 r13361
    rvm/src/org/jikesrvm/classloader/VM_Class.java                                                                      r13210 r13354
    rvm/src/org/jikesrvm/classloader/VM_NormalMethod.java                                                               r13210
    rvm/src/org/jikesrvm/classloader/VM_TypeReference.java                                                                     r13354
    rvm/src/org/jikesrvm/compilers/baseline/ia32/VM_Compiler.java                                                              r13354 r13361
    rvm/src/org/jikesrvm/scheduler/VM_Thread.java                                                                       r13210 r13354 r13361
    rvm/src/org/jikesrvm/scheduler/VM_MainThread.java                                                                   r13210 
    rvm/src/org/jikesrvm/scheduler/VM_Scheduler.java                                                                           r13354 r13361 r13403
    rvm/src/org/jikesrvm/runtime/VM_ExitStatus.java                                                                            r13354

    + The followings are patches simply for the internal debugging and logging.

    file name                                         patches
    libraryInterface/Common/src/java/lang/Thread.java                                                                           r13354
    libraryInterface/GNUClasspath/LGPL/src/gnu/classpath/jdwp/Jdwp.java                                                                       r13403
    libraryInterface/GNUClasspath/LGPL/src/gnu/classpath/jdwp/processor/ObjectReferenceCommandSet.java                                        r13403
    libraryInterface/GNUClasspath/LGPL/src/gnu/classpath/jdwp/processor/ClassTypeCommandSet.java                                              r13403
    libraryInterface/GNUClasspath/LGPL/src/gnu/classpath/jdwp/processor/VirtualMachineCommandSet.java                                         r13403
    libraryInterface/GNUClasspath/LGPL/src/gnu/classpath/jdwp/processor/PacketProcessor.java                                                  r13403
    libraryInterface/GNUClasspath/LGPL/src/gnu/classpath/jdwp/processor/ReferenceTypeCommandSet.java                                          r13403
    libraryInterface/GNUClasspath/LGPL/src/gnu/classpath/jdwp/event/Event.java                                                                r13403
    libraryInterface/GNUClasspath/LGPL/src/gnu/classpath/jdwp/event/filters/LocationOnlyFilter.java                                           r13403
    libraryInterface/GNUClasspath/LGPL/src/gnu/classpath/jdwp/event/EventManager.java                                                         r13403
    libraryInterface/GNUClasspath/LGPL/src/gnu/classpath/jdwp/transport/JdwpConnection.java                                                   r13403
    libraryInterface/GNUClasspath/LGPL/src/gnu/classpath/jdwp/transport/JdwpPacket.java                                                       r13403
    libraryInterface/GNUClasspath/LGPL/src/gnu/classpath/jdwp/value/ObjectValue.java                                                          r13403
    libraryInterface/GNUClasspath/LGPL/src/gnu/classpath/jdwp/value/StringValue.java                                                          r13403
    libraryInterface/GNUClasspath/LGPL/src/gnu/classpath/jdwp/util/MethodResult.java                                                          r13403
    libraryInterface/GNUClasspath/LGPL/src/gnu/classpath/jdwp/util/Location.java                                                              r13403
    libraryInterface/GNUClasspath/LGPL/src/gnu/classpath/debug/SystemLogger.java                                                              r13403

