* Power PC support

  + The current source code does not support power pc, but this won't
  be a hard work as we have power pc expert. This will be about adding
  around 100 source lines to the power pc specific baseline compiler
  sourc files.

* Single stepping

  * General issue: Unlike other JDWP debugging events, the single step
    requires the JDWP agent to keep the program context when the agent
    gets the request. In other words the single step completion point
    is dependent on the request point. For a machine level, the step
    completion point is next dynamic byte code instrution. For a
    source level, the completion point is the first dynamic
    instruction with different source line with respect the source
    line at the single step request.

    JVMTI/JDWP: JVMTI provides a single stepping at the byte code
    level, and JDWP agent exposes the single stepping at both byte and
    source code levels. A sequence of JVMTI single step events may
    constitute a single JDWP single stepping if the JDWP sinigle step
    request was at the source line level. If JDWP client asks more
    filters such as class exclusion, the JDWP agent would skip more
    JVMTI single stepping events.

    JDWP agent should keep the suspened location when the JDWP client
    requests the single step event. Then the JDWP agent enables the
    JVMTI byte code level single step, and resumes the application
    thread. The application thread executes one byte code instruction,
    and notifies this byte code completion event. The JDWP agent
    compares the previouly recorded location and the new location. If
    the difference between these two locations is far enough in terms
    of step depth and step size, the JDWP agent notifies the JDWP
    client of this JDWP level stepping event. Otherwise the JDWP agent
    resumes the execution, and repeat this process until it observes
    enough execution progress in the application.

    + JDWP Single Step

    "Case Step - if modKind is 10: Restricts reported step events to
    those which satisfy depth and size constraints. This modifier can
    be used with step event kinds only.
       threadID  thread   Thread in which to step 
       int         size   size of each step. See JDWP.StepSize 
       int        depth   relative call stack limit. See JDWP.StepDepth"
    [http://java.sun.com/javase/6/docs/platform/jpda/jdwp/jdwp-protocol.html#JDWP_EventRequest_Set]

    "Case SingleStep - if eventKind is JDWP.EventKind.SINGLE_STEP:
       Notification of step completion in the target VM. The step
       event is generated before the code at its location is executed.
       int        requestID	Request that generated event 
       threadID	     thread	Stepped thread 
       location	   location	Location stepped to"
     [http://java.sun.com/javase/6/docs/platform/jpda/jdwp/jdwp-protocol.html#JDWP_Event_Composite]

    + JVMTI Single Step request and callback

    "jvmtiError SetEventNotificationMode(jvmtiEnv* env, jvmtiEventMode
      mode, jvmtiEvent event_type, jthread event_thread, ...)"
    [http://java.sun.com/j2se/1.5.0/docs/guide/jvmti/jvmti.html#SetEventNotificationMode]

    "void JNICALL SingleStep(jvmtiEnv *jvmti_env, JNIEnv* jni_env,
      jthread thread, jmethodID method, jlocation location)
    
    Typically, single step events represent the completion of one VM
    instruction as defined the Java Virtual Machine
    Specification. However, some implementations may define locations
    differently."
    [http://java.sun.com/j2se/1.5.0/docs/guide/jvmti/jvmti.html#SingleStep]

    "StepDepth Constants
      INTO	0	Step into any method calls that occur before the end of the step.  
      OVER	1	Step over any method calls that occur before the end of the step.  
      OUT	2	Step out of the current method."
    [http://java.sun.com/javase/6/docs/platform/jpda/jdwp/jdwp-protocol.html#JDWP_StepDepth]

    "StepSize Constants
      MIN     0	        Step by the minimum possible amount (often a bytecode instruction).  
      LINE    1         Step to the next source line unless there is no line number
			information in which case a MIN step is done instead."
      [http://java.sun.com/javase/6/docs/platform/jpda/jdwp/jdwp-protocol.html#JDWP_StepSize]

* Method Invocation at a break point
  
  This is to support expression evalation that contains a method
  call. For instance, consider "eval Fact.fact(2) + 1"

  ------------------------------------------------------------------
  (bash) cat -n Fact.java
    ...
     5	public class Fact {
    ...
     8	  public static void main(String[] args) {
     9	    System.out.println("fact(4) = " + fact(4));
    10	  }
    ...
    17	  private static int fact(int n) {
    18	    if ( n <= 0 ) {
    19	      return 1;
    20	    } else {
    21	      return n * fact( n - 1 );
    22	    }
    23	  }
    24	}

  (bash) jdb -connect 'com.sun.jdi.RawCommandLineLaunch:command=rvm
  "-Xrunjdwp:transport=dt_socket,address=8000,suspend=y"
  Fact',address=8000 -launch

  MainThread[1] stop in Fact.main
  Set breakpoint Fact.main
  MainThread[1] cont
  Breakpoint hit: "thread=MainThread", Fact.main(), line=9 bci=0
  9        System.out.println("fact(4) = " + fact(4));

  MainThread[1] eval Fact.fact(2) + 1
   Fact.fact(2) + 1 = 3
  ------------------------------------------------------------------

  Here, the JDB internally sends the JDWP agent a request to invoke
  Fact.fact method with the integer argument value 2, and the JDWP
  agent internally activates the method via reflective call. The
  following is JDWP's related protocol commands:

  ------------------------------------------------------------------
      ClassType.InvokeMethod --> "Invokes a static method."

      ClassType.newInstance --> "Creates a new object of this type,
      invoking the specified constructor."

      ObjectReference.InvokeMethod --> "Invokes a instance method."

  [http://java.sun.com/javase/6/docs/platform/jpda/jdwp/jdwp-protocol.html]
  ------------------------------------------------------------------

  Inside the JikesRVM/JDWP, All three requests end up here:

    gnu.classpath.jdwp.VMVirtualMachine.executeMethod(..)

  The background JDWP helper thread reads the method invocation
  protocol command, and resumes the suspened application thread at the
  break point. At this time, the resumed application thread is in the
  following JDWP agent method.

  gnu.classpath.jdwp.VMVirtualMachine.ThreadInfo.suspendCurrentThread()
  
  The awaken application thread notices a method invocation request,
  and executes the target method instead of returning to the
  application code at the breakpoint. After finishing the method
  invocation, this application thread returns to the suspened status.

  Breakpoint Hit during Method Invocation: JikesRVM/JDWP agent skips
  breakpoints and any other JDWP events during method invocation. The
  first reason is because this decision would simplify the
  implementation. The second reason is that the current GNU class path
  JDWP code (gnu.classpath.jdwp) is not suitable for the another
  alternative. Let me explain the issues in the following.

          skipping vs. nested break state?

  One issue with the method invocation is how to deal with the break
  point during the method invocation. One possibility is ignoring the
  breakpoints during the method invocation. The other possibility is
  suspending the program and allowing nested break state. Which one is
  better is not clear. Rosenberg's book [How debuggers work]
  recommands skipping the breakpoint since the return of investment is
  not clear. Visual studio 2003 skipped the break point, but Visual
  studio 2005 allowed the nested break state
  [http://blogs.msdn.com/jmstall/archive/2005/03/23/400794.aspx]. The
  JDWP specification for the method invocation does not show any clear
  position about this. The hotspot VM appears catures the break point
  event during the method invocation, but it does not support the
  nested break state. The Apache DLRVM surprisingly appears as if it
  supports the nested break state.

  ------------------------------------------------------------------
  (bash) jdb -version
  This is jdb version 1.6 (J2SE version 1.6.0)
  (bash) jdb -launch Fact
  main[1] stop at Fact:18
  main[1] cont
  Breakpoint hit: "thread=main", Fact.fact(), line=18 bci=0
  18        if ( n <= 0 ) {
  main[1] eval Fact.fact(3)

  Breakpoint hit: "thread=main", Fact.fact(), line=18 bci=0
  18        if ( n <= 0 ) {
  main[1] eval Fact.fact(3)
   com.sun.jdi.InternalException: Unexpected JDWP Error: 502
   Fact.fact(3) = null 
  main[1] exit
  ------------------------------------------------------------------

  ------------------------------------------------------------------
  (bash) jdb -launch -connect com.sun.jdi.CommandLineLaunch:
	 vmexec=java,home=/var/local/bclee/harmony-jdk-653525
	  Fact 1
  main[1] stop at Fact:18
  main[1] cont
  Breakpoint hit: "thread=main", Fact.fact(), line=18 bci=0
  18        if ( n <= 0 ) {
  main[1] eval Fact.fact(3)

  Breakpoint hit: "thread=main", Fact.fact(), line=18 bci=0
  18        if ( n <= 0 ) {

  main[1] eval Fact.fact(3)

  Breakpoint hit: "thread=main", Fact.fact(), line=18 bci=0
  18        if ( n <= 0 ) {
  main[1] exit
  ------------------------------------------------------------------  

* Interface to the existing Java debuggers

 The JikesRVM will implement the subset of the SUN JVM's JDWP command
 line options:

 [http://java.sun.com/javase/6/docs/technotes/guides/jpda/conninv.html#Invocation]

  option name       JikesRVM implementation
  -----------------------------------------
  help              YES                            
  transport         dt_socket only        gnu.classpath.jdwp.transport._TRANSPORT_PROPERTY  server            YES                   gnu.classpath.jdwp.transport.SocketTransport._PROPERTY_SERVER
  address           YES                   gnu.classpath.jdwp.transport.SocketTransport._PROPERTY_ADDRESS
  timeout           NO
  launch            NO
  onthrow           NO
  onuncaught        NO
  suspend           YES                   gnu.classpath.jdwp.Jdwp._PROPERTY_SUSPEND

  The following is the help message from JikesRVM/JDWP.

  ---------------------------------------------------------------------------
  coral:~/w/jdwp$rvm -Xrunjdwp:help
  -Xrunjdwp[:help]		Print usage of the JDWP agent.
  -Xrunjdwp:[<option>=<value>, ...]		Configure the JDWP agent.

  Option             Default value       Description
  suspend=y|n        y                   Suspend VM before starting application.
  transport=...      none                Name transport. e.g. dt_socket
  server=...         n                   Listens for the debugger
  address=...        none                Transport address for the connection
  verbose=..         0                   JDWP subsystem verbose level
  ---------------------------------------------------------------------------

  An issue here is the default value for the "suspend." SUN JVM has
  "y" as a default "suspend" value, but the GNU classpath JDWP has "n"
  default value. For the compatibility with the existing tools, I'd
  prefer "y" as default value. I have two choices for this. The first
  one is to ask the GNU classpath community to switch to the "y"
  default value. The second one is that the JikesRVM's porting layer
  handles this.

