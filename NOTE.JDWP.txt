* Method Invocation and its Implementation
  
  This is to support expression evalation that contains a method
  call. For instance, consider "eval Fact.fact(2) + 1"

  ------------------------------------------------------------------
  (bash) cat -n Fact.java
    ...
     5	public class Fact {
    ...
     8	  public static void main(String[] args) {
     9	    System.out.println("fact(4) = " + fact(4));
    10	  }
    ...
    17	  private static int fact(int n) {
    18	    if ( n <= 0 ) {
    19	      return 1;
    20	    } else {
    21	      return n * fact( n - 1 );
    22	    }
    23	  }
    24	}

  (bash) jdb -connect 'com.sun.jdi.RawCommandLineLaunch:command=rvm
  "-Xrunjdwp:transport=dt_socket,address=8000,suspend=y"
  Fact',address=8000 -launch

  MainThread[1] stop in Fact.main
  Set breakpoint Fact.main
  MainThread[1] cont
  Breakpoint hit: "thread=MainThread", Fact.main(), line=9 bci=0
  9        System.out.println("fact(4) = " + fact(4));

  MainThread[1] eval Fact.fact(2) + 1
   Fact.fact(2) + 1 = 3
  ------------------------------------------------------------------

  Here, the JDB internally sends the JDWP agent a request to invoke
  Fact.fact method with the integer argument value 2, and the JDWP
  agent internally activates the method via reflective call. The
  following is JDWP's related protocol commands:

  ------------------------------------------------------------------
      ClassType.InvokeMethod --> "Invokes a static method."

      ClassType.newInstance --> "Creates a new object of this type,
      invoking the specified constructor."

      ObjectReference.InvokeMethod --> "Invokes a instance method."

  [http://java.sun.com/javase/6/docs/platform/jpda/jdwp/jdwp-protocol.html]
  ------------------------------------------------------------------

  Inside the JikesRVM/JDWP, All three requests end up here:

    gnu.classpath.jdwp.VMVirtualMachine.executeMethod(..)

  The background JDWP helper thread reads the method invocation
  protocol command, and resumes the suspened application thread at the
  break point. At this time, the resumed application thread is in the
  following JDWP agent method.

  gnu.classpath.jdwp.VMVirtualMachine.ThreadInfo.suspendCurrentThread()
  
  The awaken application thread notices a method invocation request,
  and executes the target method instead of returning to the
  application code at the breakpoint. After finishing the method
  invocation, this application thread returns to the suspened status.

* Breakpoint Hit during Method Invocation

  JikesRVM/JDWP agent skips breakpoints and any other JDWP events
  during method invocation. The first reason is because this decision
  would simplify the implementation. The second reason is that the
  current GNU class path JDWP code (gnu.classpath.jdwp) is not
  suitable for the another alternative. Let me explain the issues in
  the following.

          skipping vs. nested break state?

  One issue with the method invocation is how to deal with the break
  point during the method invocation. One possibility is ignoring the
  breakpoints during the method invocation. The other possibility is
  suspending the program and allowing nested break state. Which one is
  better is not clear. Rosenberg's book [How debuggers work]
  recommands skipping the breakpoint since the return of investment is
  not clear. Visual studio 2003 skipped the break point, but Visual
  studio 2005 allowed the nested break state
  [http://blogs.msdn.com/jmstall/archive/2005/03/23/400794.aspx]. The
  JDWP specification for the method invocation does not show any clear
  position about this. The hotspot VM appears catures the break point
  event during the method invocation, but it does not support the
  nested break state. The Apache DLRVM surprisingly appears as if it
  supports the nested break state.

  ------------------------------------------------------------------
  (bash) jdb -version
  This is jdb version 1.6 (J2SE version 1.6.0)
  (bash) jdb -launch Fact
  main[1] stop at Fact:18
  main[1] cont
  Breakpoint hit: "thread=main", Fact.fact(), line=18 bci=0
  18        if ( n <= 0 ) {
  main[1] eval Fact.fact(3)

  Breakpoint hit: "thread=main", Fact.fact(), line=18 bci=0
  18        if ( n <= 0 ) {
  main[1] eval Fact.fact(3)
   com.sun.jdi.InternalException: Unexpected JDWP Error: 502
   Fact.fact(3) = null 
  main[1] exit
  ------------------------------------------------------------------

  ------------------------------------------------------------------
  (bash) jdb -launch -connect com.sun.jdi.CommandLineLaunch:
	 vmexec=java,home=/var/local/bclee/harmony-jdk-653525
	  Fact 1
  main[1] stop at Fact:18
  main[1] cont
  Breakpoint hit: "thread=main", Fact.fact(), line=18 bci=0
  18        if ( n <= 0 ) {
  main[1] eval Fact.fact(3)

  Breakpoint hit: "thread=main", Fact.fact(), line=18 bci=0
  18        if ( n <= 0 ) {

  main[1] eval Fact.fact(3)

  Breakpoint hit: "thread=main", Fact.fact(), line=18 bci=0
  18        if ( n <= 0 ) {
  main[1] exit
  ------------------------------------------------------------------  
